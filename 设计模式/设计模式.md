# OO设计原则

>将应用中会变化的那部分取出并封装起来。这样可以使代码变化引起的意外影响变少，使系统更有弹性

>针对接口编程，而不是针对实现编程

>多用组合，少用继承

代码复用性，扩展性，维护性
每当设计代码实现后，想想该业务在未来可能发生的变化，然后分析现在的代码在业务需求变化后好不好进行扩展

# 策略模式

## 定义

策略模式是一种行为型模式，定义了算法簇，分别封装起来，让它们之间可以互相替换【可以理解为将对象和行为分开，行为定义为一个行为接口和若干具体行为的实现】。此模式让算法的变化独立于使用算法的客户。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。

## 例子

取自《Head First设计模式》

>现在有一个业务需求，设计鸭子类，具体的鸭子类都继承于一个鸭子超类Duck,Duck中封装好了所有鸭子都一样的行为。而现在，不同种类的鸭子在`飞行`和`鸭叫`这两个行为上表现不一样。比如绿头鸭用扇动翅膀飞行，嘎嘎嘎叫；玩具鸭不能飞行，吱吱吱叫；火箭鸭靠火箭推动器飞行，不会叫

**分析过程**

【运用继承+多态】
将fly()和quack()放入Duck，让每一个具体的鸭子继承Duck。若有需要，则在子类中重写这两个方法，覆盖Duck中原来的方法，从而实现每种鸭子都有自己特定的行为。这样的做法会有以下问题：
① 每次有新种类的鸭子，都要检查，看是否需要重写覆盖超类继承来的fly()和quack()。比如，玩具鸭不会飞行，那它就要重写覆盖继承来的fly()，使其什么都不做；另外还要重写覆盖继承来的quack()，使其有吱吱叫的鸭叫声(超类是嘎嘎嘎叫)
② 代码在多个子类中重复
③ 运行时的行为不容易改变
④ 很难得知所有鸭子的全部行为
⑤ 改变会牵一发而动全身，造成其他鸭子不想要的改变：比如未来还要引入一个“说人话”行为，那所有鸭子都会继承到这个行为，但是并不是所有鸭子都会“说人话”，那岂不是要给这些鸭子子类都进行重写覆盖？改动就很大了。

***

既然继承会那么多问题，那就用接口。
Flyable接口中有fly()行为，Quackable接口中有quack()行为。每种鸭子都继承自Duck，根据会不会飞/叫，来决定是否实现Flyable/Quackable接口（这就避免了不会飞的鸭子有fly()行为...不合理的情况），根据自己行为的特点，在类中实现fly()/quack()。这样的做法仍然不理想：
接口不具有实现代码，因此继承接口代码无法达到代码复用：某个行为需求变化了，那就要追踪到每个定义了该行为的实现类中去修改它，类一多，工作量就很大，而且可能造成新的错误

***
发现总是因为可能发生的变化(新需求的到来)而导致代码存在缺陷(某些代码要改)，那么运用OO原则：
>找出应用中可能会发生变化的那部分，取出并封装起来，将变与不变分开

fly()和quack()会随着鸭子种类的不同而变化，因此将这两个行为从Duck中抽出来，分别形成各自的一组类来实现各自的动作（比如fly行为有一个类实现“扇动翅膀飞行”，一个类实现“不能飞行”，一个类实现“依靠火箭推动器飞行”...）

但是仅仅这么做还是不够弹性，不能在创建鸭子的时候指定特定的飞行/叫行为给它，即无法在运行时动态地改变鸭子的行为（行为在编写代码的时候，通过直接继承行为类已经写死了）

要实现运行时可以动态修改行为，那还要运用到以下OO原则：
>针对接口编程，而不是针对实现编程

用接口FlyBehavior和QuackBehavior表示行为，制造一组行为类来实现这些接口。将这两个接口放入Duck，每种鸭子在继承Duck后，都可以继承到这两个接口。在创建具体鸭子的时候，通过构造函数将接口行为指定为对应的行为类。通过set方法，就可以在运行时动态地改变行为。这个做法是一个很大的突破：
无论是第一种方法：继承+多态，还是第二种方法：子类直接实现接口，都是依赖于“实现”，将实现绑死在鸭子的子类中，没法改变行为；而现在，鸭子的子类使用接口所表示的行为，具体的实现是在行为类中，鸭子不知道行为的实现细节。

每一个鸭子都“有一个”FlyBehavior和QuackBehavior，鸭子的行为不是继承来的，而是和适当的行为对象组合来的，这也符合了OO原则：
>多用组合，少用继承。(“有一个”可能比“是一个”更好)

**代码实现**
